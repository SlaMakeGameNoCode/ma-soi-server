<!DOCTYPE html>
<html lang="vi">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Ma S√≥i Mobile - Player</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);
            color: #fff;
            min-height: 100vh;
            padding: 20px;
        }

        .top-status {
            position: sticky;
            top: 0;
            z-index: 1200;
            margin-bottom: 12px;
            background: rgba(15, 23, 42, 0.9);
            backdrop-filter: blur(10px);
            border: 1px solid #334155;
            border-radius: 12px;
            padding: 12px 14px;
            display: grid;
            grid-template-columns: repeat(2, minmax(0, 1fr));
            gap: 10px;
            align-items: center;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.25);
        }

        .status-chip {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 10px 12px;
            border-radius: 10px;
            background: #111827;
            border: 1px solid #1f2937;
            font-weight: 600;
            font-size: 14px;
        }

        .status-chip .dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
        }

        .dot-green { background: #10b981; }
        .dot-yellow { background: #fbbf24; }

        .role-badge {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 10px 14px;
            border-radius: 999px;
            background: linear-gradient(120deg, #1e3a8a, #312e81);
            border: 1px solid rgba(59, 130, 246, 0.4);
            color: #fbbf24;
            font-weight: 700;
            box-shadow: 0 8px 20px rgba(59, 130, 246, 0.35);
        }

        .floating-actions {
            position: fixed;
            right: 18px;
            bottom: 18px;
            z-index: 1800;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .fab {
            width: 56px;
            height: 56px;
            border-radius: 50%;
            background: linear-gradient(135deg, #3b82f6, #2563eb);
            border: none;
            color: #fff;
            font-size: 24px;
            box-shadow: 0 12px 24px rgba(37, 99, 235, 0.35);
            cursor: pointer;
        }

        .toast-container {
            position: fixed;
            top: 16px;
            right: 16px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 1900;
        }

        .toast {
            min-width: 240px;
            background: #0f172a;
            border: 1px solid #1f2937;
            border-left: 4px solid #3b82f6;
            padding: 12px 14px;
            border-radius: 10px;
            box-shadow: 0 10px 24px rgba(0,0,0,0.3);
            animation: fadeIn 0.25s ease-out;
        }

        .phase-overlay {
            position: fixed;
            inset: 0;
            background: radial-gradient(circle at center, rgba(255,255,255,0.08), rgba(15,23,42,0.9));
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 2500;
            color: #fff;
            font-size: 42px;
            font-weight: 800;
            letter-spacing: 3px;
            text-transform: uppercase;
            animation: flash 0.6s ease-out;
        }

        @keyframes flash {
            0% { opacity: 0; transform: scale(0.9); }
            40% { opacity: 1; transform: scale(1.03); }
            100% { opacity: 0; transform: scale(1); }
        }

        .container {
            max-width: 600px;
            margin: 0 auto;
        }

        .card {
            background: #1e293b;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }

        h1,
        h2 {
            margin-bottom: 15px;
            text-align: center;
        }

        .hidden {
            display: none !important;
        }

        /* Buttons */
        .btn {
            width: 100%;
            padding: 16px;
            border: none;
            border-radius: 12px;
            font-size: 18px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            margin-bottom: 10px;
        }

        .btn-primary {
            background: #3b82f6;
            color: #fff;
        }

        .btn-secondary {
            background: #475569;
            color: #fff;
        }

        .btn-danger {
            background: #ef4444;
            color: #fff;
        }

        /* Inputs */
        input {
            width: 100%;
            padding: 15px;
            border-radius: 8px;
            border: 2px solid #334155;
            background: #0f172a;
            color: #fff;
            margin-bottom: 15px;
            font-size: 16px;
        }

        /* Lobby */
        .player-item {
            display: flex;
            align-items: center;
            padding: 12px;
            background: #0f172a;
            border-radius: 8px;
            margin-bottom: 8px;
        }

        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 10px;
        }

        .online {
            background: #10b981;
        }

        .offline {
            background: #ef4444;
        }

        /* Game UI */
        .role-card {
            text-align: center;
            border: 2px solid #3b82f6;
            padding: 20px;
            background: #1e293b;
            margin-bottom: 20px;
            position: relative;
        }

        .role-title {
            font-size: 24px;
            font-weight: bold;
            color: #fbbf24;
            margin-bottom: 5px;
        }

        .role-desc {
            color: #94a3b8;
            font-size: 14px;
        }

        .guide-btn {
            position: absolute;
            top: 15px;
            right: 15px;
            width: 35px;
            height: 35px;
            border-radius: 50%;
            background: #3b82f6;
            color: #fff;
            border: none;
            font-size: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .guide-btn:hover {
            background: #2563eb;
            transform: scale(1.1);
        }

        .role-guide-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 2500;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .role-guide-content {
            background: #1e293b;
            border-radius: 12px;
            max-width: 500px;
            width: 100%;
            max-height: 80vh;
            overflow-y: auto;
            padding: 25px;
            border: 2px solid #3b82f6;
        }

        .role-guide-content h2 {
            color: #fbbf24;
            margin-bottom: 15px;
            font-size: 28px;
            text-align: center;
        }

        .role-guide-content h3 {
            color: #3b82f6;
            margin-top: 20px;
            margin-bottom: 10px;
            font-size: 18px;
        }

        .role-guide-content p {
            color: #cbd5e1;
            line-height: 1.6;
            margin-bottom: 10px;
        }

        .role-guide-content ul {
            color: #cbd5e1;
            margin-left: 20px;
            margin-bottom: 15px;
        }

        .role-guide-content li {
            margin-bottom: 8px;
            line-height: 1.5;
        }

        .guide-close-btn {
            width: 100%;
            padding: 12px;
            background: #ef4444;
            color: #fff;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            margin-top: 20px;
        }

        .guide-close-btn:hover {
            background: #dc2626;
        }

        .phase-indicator {
            text-align: center;
            font-size: 20px;
            font-weight: bold;
            padding: 10px;
            background: #334155;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .timer-display {
            text-align: center;
            font-size: 48px;
            font-weight: bold;
            color: #fbbf24;
            padding: 20px;
            background: #1e293b;
            border-radius: 12px;
            margin-bottom: 20px;
            border: 2px solid #3b82f6;
            display: none;
        }

        .timer-display.warning {
            color: #ef4444;
            border-color: #ef4444;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.7;
            }
        }

        /* Action List */
        .action-list {
            display: grid;
            gap: 10px;
        }

        .action-btn {
            background: #0f172a;
            padding: 15px;
            border: 1px solid #334155;
            border-radius: 8px;
            color: #fff;
            text-align: left;
            cursor: pointer;
        }

        .action-btn.selected {
            border-color: #3b82f6;
            background: #1e3a8a;
        }

        /* Logs */
        #gameLogs {
            max-height: 150px;
            overflow-y: auto;
            font-size: 12px;
            color: #cbd5e1;
            padding: 10px;
            background: #0f172a;
            border-radius: 8px;
        }

        .vote-leader-notification {
            background: #1e293b;
            border: 2px solid #f59e0b;
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 20px;
            text-align: center;
            display: none;
        }

        .vote-leader-notification h3 {
            color: #f59e0b;
            margin-bottom: 8px;
            font-size: 16px;
        }

        .vote-leader-notification .leader-name {
            font-size: 24px;
            font-weight: bold;
            color: #fff;
            margin-bottom: 5px;
        }

        .vote-leader-notification .vote-count {
            color: #94a3b8;
            font-size: 14px;
        }

        /* Chat */
        .chat-card {
            display: none;
        }

        .chat-messages {
            max-height: 200px;
            overflow-y: auto;
            background: #0f172a;
            border: 1px solid #334155;
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 10px;
            font-size: 14px;
            line-height: 1.4;
        }

        .chat-entry { margin-bottom: 6px; }
        .chat-entry .name { color: #38bdf8; font-weight: 600; margin-right: 6px; }
        .chat-entry .time { color: #94a3b8; font-size: 11px; margin-left: 6px; }

        .chat-input-row {
            display: flex;
            gap: 8px;
        }

        .chat-input-row input {
            flex: 1;
            padding: 12px;
            border-radius: 8px;
            border: 1px solid #334155;
            background: #0f172a;
            color: #fff;
        }

        .chat-input-row button {
            padding: 12px 16px;
            border: none;
            border-radius: 8px;
            background: #3b82f6;
            color: #fff;
            font-weight: 600;
            cursor: pointer;
        }

        .chat-disabled {
            padding: 10px;
            border-radius: 8px;
            background: #1f2937;
            border: 1px dashed #475569;
            color: #94a3b8;
            text-align: center;
            margin-top: 8px;
        }
    </style>
</head>

<body>
    <div class="container">
        <!-- JOIN SCREEN -->
        <div id="joinScreen">
            <div class="card" style="text-align: center;">
                <h1 style="font-size: 40px;">üê∫</h1>
                <h2>Ma S√≥i Mobile</h2>
                <input type="text" id="roomCodeInput" placeholder="M√£ Ph√≤ng" readonly>
                <input type="text" id="playerNameInput" placeholder="T√™n c·ªßa b·∫°n">
                <button class="btn btn-primary" id="joinBtn">Tham Gia</button>
            </div>
        </div>

        <!-- LOBBY SCREEN -->
        <div id="lobbyScreen" class="hidden">
            <div class="card">
                <h2>Ph√≤ng Ch·ªù</h2>
                <p style="text-align: center; color: #fbbf24; font-size: 20px; margin-bottom: 10px;" id="lobbyRoomCode">
                    ---</p>
                <div id="lobbyPlayerList"></div>
                <p style="text-align: center; color: #94a3b8; margin-top: 15px;">Ch·ªù Host b·∫Øt ƒë·∫ßu...</p>
            </div>
        </div>

        <!-- GAME SCREEN -->
        <div id="gameScreen" class="hidden">
            <div class="top-status">
                <div class="status-chip" id="aliveStatus">
                    <span class="dot dot-green"></span>
                    <span>ƒêang t·∫£i...</span>
                </div>
                <div class="status-chip" id="phaseStatus">
                    <span class="dot dot-yellow"></span>
                    <span>Pha: --</span>
                </div>
                <div class="role-badge" id="roleBadge" style="grid-column: span 2; justify-self: start;">
                    <span id="roleBadgeIcon">üß©</span>
                    <span id="roleBadgeText">Vai tr√≤: --</span>
                </div>
            </div>

            <!-- Role Info -->
            <div class="card role-card">
                <button class="guide-btn" onclick="showRoleGuide()" title="H∆∞·ªõng d·∫´n vai tr√≤">‚ùì</button>
                <div class="role-title" id="roleName">---</div>
                <div class="role-desc" id="roleDesc">---</div>
            </div>

            <!-- Phase & Status -->
            <div class="phase-indicator" id="phaseDisplay">NIGHT 1</div>

            <!-- Timer Display -->
            <div class="timer-display" id="timerDisplay">--</div>

            <!-- Discussion Ready -->
            <div class="card" id="readyCard" style="display:none; margin-top:12px;">
                <h3 style="margin-bottom:8px;">Th·∫£o lu·∫≠n xong?</h3>
                <p id="readyStatusText" style="color:#94a3b8; margin-bottom:8px;">0/0 ƒë√£ s·∫µn s√†ng</p>
                <button class="btn btn-secondary" id="readyBtn" style="width:100%;">ƒê√£ th·∫£o lu·∫≠n xong</button>
            </div>

            <!-- Vote Leader Notification -->
            <div class="vote-leader-notification" id="voteLeaderNotification">
                <h3>üó≥Ô∏è ƒêang D·∫´n ƒê·∫ßu</h3>
                <div class="leader-name" id="voteLeaderName">---</div>
                <div class="vote-count" id="voteLeaderCount">--- phi·∫øu</div>
            </div>

            <!-- Action Area -->
            <div class="card" id="actionArea">
                <h3 id="actionTitle" style="margin-bottom: 10px;">H√†nh ƒê·ªông</h3>
                <div id="wolfKillNotice" class="hidden" style="display:none; margin-bottom:10px; padding:10px; border-radius:8px; background:#0f172a; border:1px solid #f97316; color:#fbbf24; font-weight:600;">
                    üê∫ S√≥i ƒëang nh·∫Øm: <span id="wolfKillTarget">--</span>
                </div>
                <div id="playerSelect" class="action-list"></div>
                <button class="btn btn-primary" id="confirmActionBtn" style="margin-top: 15px;">X√°c Nh·∫≠n</button>
            </div>

            <!-- Chat -->
            <div class="card chat-card" id="chatCard">
                <h3>Chat</h3>
                <div id="chatMessages" class="chat-messages"></div>
                <div class="chat-input-row">
                    <input type="text" id="chatInput" placeholder="Nh·∫Øn g√¨ ƒë√≥..." maxlength="200">
                    <button id="chatSendBtn">G·ª≠i</button>
                </div>
                <div id="chatDisabled" class="chat-disabled hidden">Chat ƒëang t·∫Øt b·ªüi Host</div>
            </div>

            <div class="card" id="suspectArea" style="display:none;">
                <h3 style="margin-bottom: 6px;">B·∫£ng Nghi Ng·ªù üïµÔ∏è</h3>
                <p style="color:#94a3b8; font-size:13px; margin-bottom:10px;">Ch·ªçn ng∆∞·ªùi b·∫°n nghi l√† S√≥i (kh√¥ng ·∫£nh h∆∞·ªüng gameplay, ch·ªâ ghi log).</p>
                <div id="suspectSelect" class="action-list"></div>
                <button class="btn btn-secondary" id="confirmSuspectBtn" style="margin-top: 12px;">G·ª≠i nghi ng·ªù</button>
            </div>

            <!-- Logs -->
            <div class="card">
                <h3>Th√¥ng B√°o</h3>
                <div id="gameLogs"></div>
            </div>
        </div>

        <div class="phase-overlay" id="phaseOverlay">PHASE</div>
        <div class="toast-container" id="toastContainer"></div>

        <div class="floating-actions">
            <button class="fab" id="toggleActionFab" title="M·ªü/ƒê√≥ng khu v·ª±c h√†nh ƒë·ªông">‚ö°</button>
        </div>

        <!-- Narrator Notification Modal -->
        <div id="narratorOverlay" class="hidden"
            style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); z-index: 2000; display: flex; justify-content: center; align-items: center; flex-direction: column;">
            <div style="text-align: center; color: #fff; padding: 20px;">
                <h1 id="narTitle"
                    style="font-size: 32px; color: #fbbf24; margin-bottom: 20px; text-transform: uppercase; text-shadow: 0 0 10px #fbbf24;">
                    HELLO</h1>
                <p id="narMessage"
                    style="font-size: 20px; line-height: 1.5; color: #e2e8f0; max-width: 300px; margin: 0 auto;"></p>
                <button class="btn btn-primary" onclick="closeNarrator()"
                    style="margin-top: 40px; width: 200px; font-size: 18px;">OK</button>
            </div>
        </div>

        <!-- Role Guide Modal -->
        <div id="roleGuideModal" class="hidden role-guide-modal" onclick="if(event.target === this) closeRoleGuide()">
            <div class="role-guide-content" id="roleGuideContent">
                <!-- Content will be populated by JavaScript -->
            </div>
        </div>
    </div>

    <script src="/socket.io/socket.io.js"></script>
    <script>
        const socket = io();

        // State
        let myPlayerId = null;
        let myRole = null;
        let selectedTarget = null;
        let currentPlayers = [];
        let currentPhase = 'lobby';
    let suspectTarget = null;
    let suspectLocked = false;
    let chatEnabled = false;
    let chatLog = [];
    let pendingExecutionId = null;
        let readySent = false;
        let readyCounts = { ready: 0, total: 0 };
        let phaseOverlayTimer = null;

        // Role Guide Data
        const ROLE_GUIDES = {
            alphaWolf: {
                title: 'S√≥i ƒê·∫ßu ƒê√†n üê∫',
                faction: 'Phe S√≥i',
                winCondition: 'Ti√™u di·ªát t·∫•t c·∫£ D√¢n L√†ng ho·∫∑c s·ªë S√≥i b·∫±ng/nhi·ªÅu h∆°n s·ªë D√¢n L√†ng c√≤n l·∫°i',
                abilities: [
                    '<strong>KILL (Gi·∫øt)</strong>: M·ªói ƒë√™m, c√πng c√°c S√≥i kh√°c b·ªè phi·∫øu ch·ªçn 1 ng∆∞·ªùi ƒë·ªÉ gi·∫øt',
                    '<strong>CURSE (Nguy·ªÅn R·ªßa)</strong>: Ch·ªâ d√πng 1 l·∫ßn duy nh·∫•t trong c·∫£ game. N·∫øu ng∆∞·ªùi b·ªã nguy·ªÅn r·ªßa ch·∫øt b·ªüi S√≥i trong C√ôNG ƒê√äM ƒê√ì, h·ªç s·∫Ω h·ªìi sinh v√† tr·ªü th√†nh S√≥i'
                ],
                mechanics: [
                    'Ph·∫£i ph·ªëi h·ª£p v·ªõi c√°c S√≥i kh√°c ƒë·ªÉ ch·ªçn m·ª•c ti√™u gi·∫øt',
                    'N·∫øu nhi·ªÅu S√≥i ch·ªçn kh√°c m·ª•c ti√™u, ng∆∞·ªùi c√≥ nhi·ªÅu phi·∫øu nh·∫•t s·∫Ω b·ªã gi·∫øt',
                    'Kh·∫£ nƒÉng CURSE ch·ªâ c√≥ hi·ªáu l·ª±c n·∫øu m·ª•c ti√™u b·ªã gi·∫øt b·ªüi S√≥i trong c√πng ƒë√™m ƒë√≥'
                ]
            },
            wolf: {
                title: 'S√≥i Th∆∞·ªùng üê∫',
                faction: 'Phe S√≥i',
                winCondition: 'Ti√™u di·ªát t·∫•t c·∫£ D√¢n L√†ng ho·∫∑c s·ªë S√≥i b·∫±ng/nhi·ªÅu h∆°n s·ªë D√¢n L√†ng c√≤n l·∫°i',
                abilities: [
                    '<strong>KILL (Gi·∫øt)</strong>: M·ªói ƒë√™m, c√πng c√°c S√≥i kh√°c b·ªè phi·∫øu ch·ªçn 1 ng∆∞·ªùi ƒë·ªÉ gi·∫øt'
                ],
                mechanics: [
                    'Ph·∫£i ph·ªëi h·ª£p v·ªõi c√°c S√≥i kh√°c (bao g·ªìm S√≥i ƒê·∫ßu ƒê√†n) ƒë·ªÉ ch·ªçn m·ª•c ti√™u',
                    'N·∫øu nhi·ªÅu S√≥i ch·ªçn kh√°c m·ª•c ti√™u, ng∆∞·ªùi c√≥ nhi·ªÅu phi·∫øu nh·∫•t s·∫Ω b·ªã gi·∫øt',
                    'Bi·∫øt ƒë∆∞·ª£c ai l√† S√≥i trong nh√≥m'
                ]
            },
            detective: {
                title: 'Th√°m T·ª≠ üïµÔ∏è',
                faction: 'Phe D√¢n L√†ng',
                winCondition: 'Ti√™u di·ªát t·∫•t c·∫£ S√≥i',
                abilities: [
                    '<strong>CHECK (ƒêi·ªÅu Tra)</strong>: M·ªói ƒë√™m, ch·ªçn 1 ng∆∞·ªùi ƒë·ªÉ ki·ªÉm tra xem h·ªç c√≥ th·ª±c hi·ªán h√†nh ƒë·ªông ƒë√™m ƒë√≥ hay kh√¥ng'
                ],
                mechanics: [
                    'K·∫øt qu·∫£ s·∫Ω cho bi·∫øt m·ª•c ti√™u "C√ì ho·∫°t ƒë·ªông" ho·∫∑c "KH√îNG ho·∫°t ƒë·ªông"',
                    'C√°c vai tr√≤ c√≥ ho·∫°t ƒë·ªông ƒë√™m: S√≥i, S√≥i ƒê·∫ßu ƒê√†n, Th√°m T·ª≠, Ti√™n Tri, Ph√π Th·ªßy, V·ªá Sƒ©, Th·ª£ SƒÉn',
                    'D√¢n L√†ng th∆∞·ªùng v√† K·∫ª Ph·∫£n B·ªôi kh√¥ng c√≥ ho·∫°t ƒë·ªông ƒë√™m'
                ]
            },
            seer: {
                title: 'Ti√™n Tri üîÆ',
                faction: 'Phe D√¢n L√†ng',
                winCondition: 'Ti√™u di·ªát t·∫•t c·∫£ S√≥i',
                abilities: [
                    '<strong>CHECK (Nh√¨n Th·∫•u)</strong>: M·ªói ƒë√™m, ch·ªçn 1 ng∆∞·ªùi ƒë·ªÉ bi·∫øt h·ªç thu·ªôc phe S√≥i hay phe Ng∆∞·ªùi'
                ],
                mechanics: [
                    'K·∫øt qu·∫£ s·∫Ω cho bi·∫øt m·ª•c ti√™u l√† "S√ìI üê∫" ho·∫∑c "NG∆Ø·ªúI üßë"',
                    'S√≥i ƒê·∫ßu ƒê√†n v√† S√≥i Th∆∞·ªùng ƒë·ªÅu ƒë∆∞·ª£c x√°c ƒë·ªãnh l√† S√≥i',
                    'K·∫ª Ph·∫£n B·ªôi ƒë∆∞·ª£c x√°c ƒë·ªãnh l√† Ng∆∞·ªùi (phe Trung L·∫≠p)'
                ]
            },
            witch: {
                title: 'Ph√π Th·ªßy üßô',
                faction: 'Phe D√¢n L√†ng',
                winCondition: 'Ti√™u di·ªát t·∫•t c·∫£ S√≥i',
                abilities: [
                    '<strong>SAVE (C·ª©u)</strong>: C√≥ 1 l·ªç thu·ªëc h·ªìi sinh, d√πng 1 l·∫ßn duy nh·∫•t. C√≥ th·ªÉ c·ª©u ng∆∞·ªùi b·ªã S√≥i gi·∫øt trong ƒë√™m ƒë√≥',
                    '<strong>KILL (Gi·∫øt)</strong>: C√≥ 1 l·ªç thu·ªëc ƒë·ªôc, d√πng 1 l·∫ßn duy nh·∫•t. C√≥ th·ªÉ gi·∫øt 1 ng∆∞·ªùi b·∫•t k·ª≥ v√†o ban ƒë√™m'
                ],
                mechanics: [
                    'M·ªói lo·∫°i thu·ªëc ch·ªâ d√πng ƒë∆∞·ª£c 1 l·∫ßn trong c·∫£ game',
                    'C√≥ th·ªÉ d√πng c·∫£ 2 lo·∫°i thu·ªëc trong c√πng 1 ƒë√™m',
                    'Thu·ªëc h·ªìi sinh ch·ªâ c√≥ hi·ªáu l·ª±c v·ªõi ng∆∞·ªùi b·ªã S√≥i gi·∫øt, kh√¥ng c·ª©u ƒë∆∞·ª£c ng∆∞·ªùi b·ªã treo c·ªï',
                    'N·∫øu V·ªá Sƒ© b·∫£o v·ªá ng∆∞·ªùi b·ªã Ph√π Th·ªßy gi·∫øt, ng∆∞·ªùi ƒë√≥ s·∫Ω s·ªëng s√≥t (nh∆∞ng Ph√π Th·ªßy v·∫´n m·∫•t l·ªç thu·ªëc)'
                ]
            },
            bodyguard: {
                title: 'V·ªá Sƒ© üõ°Ô∏è',
                faction: 'Phe D√¢n L√†ng',
                winCondition: 'Ti√™u di·ªát t·∫•t c·∫£ S√≥i',
                abilities: [
                    '<strong>PROTECT (B·∫£o V·ªá)</strong>: M·ªói ƒë√™m, ch·ªçn 1 ng∆∞·ªùi ƒë·ªÉ b·∫£o v·ªá kh·ªèi m·ªçi c√°i ch·∫øt v√†o ƒë√™m ƒë√≥'
                ],
                mechanics: [
                    'KH√îNG ƒë∆∞·ª£c b·∫£o v·ªá c√πng 1 ng∆∞·ªùi 2 ƒë√™m li√™n ti·∫øp',
                    'C√≥ th·ªÉ t·ª± b·∫£o v·ªá b·∫£n th√¢n',
                    'B·∫£o v·ªá kh·ªèi c·∫£ S√≥i gi·∫øt V√Ä Ph√π Th·ªßy gi·∫øt',
                    'Kh√¥ng th·ªÉ b·∫£o v·ªá kh·ªèi Th·ª£ SƒÉn k√©o ch·∫øt (Death Link)'
                ]
            },
            hunter: {
                title: 'Th·ª£ SƒÉn üèπ',
                faction: 'Phe D√¢n L√†ng',
                winCondition: 'Ti√™u di·ªát t·∫•t c·∫£ S√≥i',
                abilities: [
                    '<strong>PIN (Ghim M·ª•c Ti√™u)</strong>: M·ªói ƒë√™m, ch·ªçn 1 ng∆∞·ªùi ƒë·ªÉ ghim. N·∫øu Th·ª£ SƒÉn ch·∫øt (b·∫•t k·ª≥ l√Ω do g√¨), ng∆∞·ªùi b·ªã ghim s·∫Ω ch·∫øt theo'
                ],
                mechanics: [
                    'C√≥ th·ªÉ thay ƒë·ªïi m·ª•c ti√™u ghim m·ªói ƒë√™m',
                    'Death Link (K√©o ch·∫øt) k√≠ch ho·∫°t khi Th·ª£ SƒÉn ch·∫øt b·ªüi B·∫§T K·ª≤ nguy√™n nh√¢n n√†o: S√≥i gi·∫øt, Ph√π Th·ªßy gi·∫øt, ho·∫∑c b·ªã treo c·ªï',
                    'Death Link KH√îNG TH·ªÇ NGƒÇN C·∫¢N - v∆∞·ª£t qua c·∫£ V·ªá Sƒ© b·∫£o v·ªá',
                    'Kh√¥ng th·ªÉ ghim ch√≠nh m√¨nh'
                ]
            },
            traitor: {
                title: 'K·∫ª Ph·∫£n B·ªôi üé≠',
                faction: 'Phe Trung L·∫≠p',
                winCondition: 'B·ªã treo c·ªï ho·∫∑c b·ªã S√≥i gi·∫øt v√†o Ng√†y/ƒê√™m 1',
                abilities: [
                    'Kh√¥ng c√≥ kh·∫£ nƒÉng ƒë·∫∑c bi·ªát'
                ],
                mechanics: [
                    'Th·∫Øng ngay l·∫≠p t·ª©c n·∫øu b·ªã treo c·ªï v√†o Ng√†y 1',
                    'N·∫øu s·ªëng s√≥t qua Ng√†y 1, m·∫•t ƒëi·ªÅu ki·ªán th·∫Øng ƒë·∫∑c bi·ªát v√† tr·ªü th√†nh D√¢n L√†ng th∆∞·ªùng',
                    'Ti√™n Tri soi s·∫Ω th·∫•y l√† "NG∆Ø·ªúI" (kh√¥ng ph·∫£i S√≥i)',
                    'M·ª•c ti√™u l√† c·ªë g·∫Øng b·ªã nghi ng·ªù v√† b·ªã treo c·ªï s·ªõm'
                ]
            },
            villager: {
                title: 'D√¢n L√†ng üßë‚Äçüåæ',
                faction: 'Phe D√¢n L√†ng',
                winCondition: 'Ti√™u di·ªát t·∫•t c·∫£ S√≥i',
                abilities: [
                    'Kh√¥ng c√≥ kh·∫£ nƒÉng ƒë·∫∑c bi·ªát'
                ],
                mechanics: [
                    'Kh√¥ng c√≥ h√†nh ƒë·ªông v√†o ban ƒë√™m',
                    'Ch·ªâ c√≥ th·ªÉ b·ªè phi·∫øu treo c·ªï v√†o ban ng√†y',
                    'Ph·∫£i d·ª±a v√†o quan s√°t v√† th·∫£o lu·∫≠n ƒë·ªÉ t√¨m ra S√≥i'
                ]
            }
        };

        const ROLE_ICONS = {
            alphaWolf: 'üê∫',
            wolf: 'üê∫',
            detective: 'üïµÔ∏è',
            seer: 'üîÆ',
            witch: 'üßô',
            bodyguard: 'üõ°Ô∏è',
            hunter: 'üèπ',
            traitor: 'üé≠',
            villager: 'üåæ',
            lawyer: '‚öñÔ∏è'
        };

        function showToast(message, type = 'info') {
            const container = document.getElementById('toastContainer');
            if (!container) return;
            const div = document.createElement('div');
            div.className = 'toast';
            const color = type === 'success' ? '#22c55e' : type === 'warn' ? '#fbbf24' : '#3b82f6';
            div.style.borderLeftColor = color;
            div.innerText = message;
            container.appendChild(div);
            setTimeout(() => div.remove(), 2200);
        }

        function isCurrentPlayerDead() {
            const me = currentPlayers.find(p => p.id === myPlayerId);
            // If we don't have our row yet, treat as "unknown" (not dead) to avoid disabling UI prematurely.
            if (!me) return false;
            return !me.alive;
        }

        function updateReadyUI(totalOverride = null) {
            if (!readyCard) return;
            const total = totalOverride !== null ? totalOverride : currentPlayers.filter(p => !p.isHost && p.alive).length;
            readyCounts.total = total;
            readyStatusText.innerText = `${readyCounts.ready}/${total} ƒë√£ s·∫µn s√†ng`;
            readyBtn.disabled = readySent || isCurrentPlayerDead();
            readyBtn.innerText = readySent ? 'ƒê√£ x√°c nh·∫≠n' : 'ƒê√£ th·∫£o lu·∫≠n xong';
            
            // Color: green if not sent, gray if sent
            if (readySent) {
                readyBtn.style.background = '#6b7280';
            } else {
                readyBtn.style.background = '#22c55e'; // Green
            }
            
            readyCard.style.display = (currentPhase === 'day' && !isCurrentPlayerDead()) ? 'block' : 'none';
        }

        function showPhaseOverlay(text, duration = 3) {
            const overlay = document.getElementById('phaseOverlay');
            let seconds = duration;
            overlay.style.display = 'flex';
            overlay.innerHTML = `<div style="text-align:center;"><div style="font-size:28px; font-weight:700; margin-bottom:6px;">${text}</div><div id="phaseCountdown" style="font-size:22px; color:#fbbf24;">${seconds}s</div></div>`;
            if (phaseOverlayTimer) clearInterval(phaseOverlayTimer);
            phaseOverlayTimer = setInterval(() => {
                seconds -= 1;
                const counter = document.getElementById('phaseCountdown');
                if (counter) counter.innerText = `${Math.max(0, seconds)}s`;
                if (seconds <= 0) {
                    clearInterval(phaseOverlayTimer);
                    overlay.style.display = 'none';
                }
            }, 1000);
        }

        function updateStatusBar(phase) {
            const aliveStatus = document.getElementById('aliveStatus');
            const phaseStatus = document.getElementById('phaseStatus');
            const roleBadgeText = document.getElementById('roleBadgeText');
            const roleBadgeIcon = document.getElementById('roleBadgeIcon');

            const alive = currentPlayers.filter(p => !p.isHost && p.alive).length;
            const total = currentPlayers.filter(p => !p.isHost).length;
            aliveStatus.querySelector('span:last-child').innerText = `${alive} / ${total} ƒëang s·ªëng`;

            phaseStatus.querySelector('span:last-child').innerText = `Pha: ${phase || currentPhase}`;

            if (myRole) {
                roleBadgeText.innerText = `Vai tr√≤: ${myRole.toUpperCase()}`;
                roleBadgeIcon.innerText = ROLE_ICONS[myRole] || 'üß©';
            }
        }

        function renderSuspicionUI() {
            const area = document.getElementById('suspectArea');
            const list = document.getElementById('suspectSelect');
            const btn = document.getElementById('confirmSuspectBtn');
            const me = currentPlayers.find(p => p.id === myPlayerId);

            if (!me) {
                area.style.display = 'none';
                // Request latest state; this avoids misclassifying as dead during initial sync.
                try { socket.emit('GET_PLAYERS'); } catch (e) { }
                return;
            }

            if (!me.alive || currentPhase !== 'night') {
                area.style.display = 'none';
                return;
            }

            area.style.display = 'block';
            list.innerHTML = '';
            suspectTarget = null;
            btn.disabled = false;

            currentPlayers.filter(p => !p.isHost && p.alive && p.id !== myPlayerId).forEach(p => {
                const div = document.createElement('div');
                div.className = 'action-btn';
                div.innerText = `${p.name}`;
                div.onclick = () => {
                    document.querySelectorAll('#suspectSelect .action-btn').forEach(b => b.classList.remove('selected'));
                    div.classList.add('selected');
                    suspectTarget = p.id;
                };
                list.appendChild(div);
            });

            btn.onclick = () => {
                if (!suspectTarget) return alert('Ch∆∞a ch·ªçn ai ƒë·ªÉ nghi ng·ªù');
                if (suspectLocked) return;
                suspectLocked = true;
                socket.emit('SUSPECT_VOTE', { targetId: suspectTarget });
                showToast('ƒê√£ g·ª≠i nghi ng·ªù', 'success');
                btn.disabled = true;
                btn.innerText = 'ƒê√£ g·ª≠i';
                setTimeout(() => btn.innerText = 'G·ª≠i nghi ng·ªù', 1200);
            };
        }

        // DOM Elements
        const screens = {
            join: document.getElementById('joinScreen'),
            lobby: document.getElementById('lobbyScreen'),
            game: document.getElementById('gameScreen')
        };

        const readyCard = document.getElementById('readyCard');
        const readyBtn = document.getElementById('readyBtn');
        const readyStatusText = document.getElementById('readyStatusText');

        // Chat DOM
        const chatCard = document.getElementById('chatCard');
        const chatMessagesEl = document.getElementById('chatMessages');
        const chatInput = document.getElementById('chatInput');
        const chatSendBtn = document.getElementById('chatSendBtn');
        const chatDisabled = document.getElementById('chatDisabled');

        // URL Params
        const urlParams = new URLSearchParams(window.location.search);
        const roomCode = urlParams.get('room') || window.location.pathname.split('/join/')[1];
        const fromHost = urlParams.get('fromHost') === '1';

        // Prefer query token; fallback to sessionStorage (for cases where query params lost)
        let reconnectToken = urlParams.get('token');
        let presetName = urlParams.get('name');
        const storedRoomCode = sessionStorage.getItem('hostRoomCode');
        const storedToken = sessionStorage.getItem('hostToken');
        const storedName = sessionStorage.getItem('hostName');
        if (!reconnectToken && roomCode && storedRoomCode === roomCode && storedToken) {
            reconnectToken = storedToken;
            presetName = presetName || storedName || 'Host';
        }

        if (roomCode) document.getElementById('roomCodeInput').value = roomCode;
        if (presetName) document.getElementById('playerNameInput').value = presetName;
    let autoJoinSent = false;

        // --- HANDLERS ---

        document.getElementById('joinBtn').addEventListener('click', () => {
            const name = document.getElementById('playerNameInput').value;
            if (!roomCode) return alert("Vui l√≤ng nh·∫≠p m√£ ph√≤ng");

            const payload = reconnectToken ?
                { roomCode, playerName: name || presetName || 'Host', token: reconnectToken } :
                { roomCode, playerName: name };

            socket.emit('JOIN_ROOM', payload);
            autoJoinSent = true;
        });

        // Auto join if token provided (ex-host in AI mode)
        socket.on('connect', () => {
            if (roomCode && reconnectToken && !autoJoinSent) {
                socket.emit('JOIN_ROOM', { roomCode, playerName: presetName || 'Host', token: reconnectToken });
                autoJoinSent = true;
            }
        });

        readyBtn.addEventListener('click', () => {
            if (readySent) return;
            readySent = true;
            readyBtn.disabled = true;
            readyBtn.style.background = '#6b7280'; // Gray after clicked
            readyBtn.innerText = 'ƒê√£ x√°c nh·∫≠n';
            socket.emit('READY_FOR_VOTE');
        });

        // Chat send handler
        chatSendBtn.addEventListener('click', () => {
            if (!chatEnabled) {
                showToast('Chat ƒëang t·∫Øt', 'warn');
                return;
            }
            const msg = chatInput.value.trim();
            if (!msg) return;
            socket.emit('SEND_CHAT', { message: msg });
            chatInput.value = '';
        });

        // --- SOCKET EVENTS ---

        socket.on('ROOM_CREATED', (data) => { // Handled same as Join for player
            myPlayerId = data.playerId;
            showScreen('lobby');
            document.getElementById('lobbyRoomCode').innerText = data.roomCode;
        });

        socket.on('RECONNECTED', (data) => {
            myPlayerId = data.playerId || myPlayerId;
            myRole = data.role || myRole;
            console.log('[CLIENT] RECONNECTED: myPlayerId=', myPlayerId, 'myRole=', myRole);
            const state = data.gameState;
            if (state) {
                currentPlayers = state.players || currentPlayers;
                currentPhase = state.phase || currentPhase;
                console.log('[CLIENT] RECONNECTED state: phase=', currentPhase, 'players=', currentPlayers.length);
                showScreen('game');
                // Ensure role/name UI is consistent after reconnect
                const meNow = currentPlayers.find(p => p.id === myPlayerId);
                console.log('[CLIENT] RECONNECTED me:', meNow ? `${meNow.name} alive=${meNow.alive}` : 'NOT FOUND');
                renderRole(myRole, meNow ? meNow.name : 'B·∫°n');

                updateStatusBar(`Pha: ${currentPhase}`);
                setupActionUI(currentPhase);
                showPhaseOverlay((currentPhase || '').toUpperCase());
            }

            // Note: setupActionUI now handles missing player data by requesting GET_PLAYERS.
        });

        socket.on('PLAYER_JOINED', (data) => {
            currentPlayers = data.players;
            console.log('[CLIENT] PLAYER_JOINED: received', data.players.length, 'players. myPlayerId=', myPlayerId);
            const me = currentPlayers.find(p => p.id === myPlayerId);
            console.log('[CLIENT] Found me:', me ? `${me.name} alive=${me.alive}` : 'NOT FOUND');
            
            renderLobby(data.players);
            updateStatusBar();
            renderSuspicionUI();

            // If already in game, switch to game screen and keep UI synced
            if (currentPhase && currentPhase !== 'lobby' && currentPhase !== 'end') {
                showScreen('game');
                const meNow = currentPlayers.find(p => p.id === myPlayerId);
                if (meNow && myRole) {
                    renderRole(myRole, meNow.name);
                }
            }

            // If in game, refresh Action UI to reflect Alive statuses
            if (currentPhase !== 'lobby' && currentPhase !== 'end') {
                setupActionUI(currentPhase);
            }

            // Update ready counter during day phase
            if (currentPhase === 'day') {
                const aliveNonHost = currentPlayers.filter(p => p.alive && !p.host).length;
                readyCounts.total = aliveNonHost;
                updateReadyUI(aliveNonHost);
            }
        });


        socket.on('DISCUSSION_READY', (data) => {
            console.log('[DISCUSSION_READY]', data);
            readyCounts.ready = data.ready;
            readyCounts.total = data.total;
            updateReadyUI(data.total);
            showToast(`${data.playerName} ƒë√£ s·∫µn s√†ng (${data.ready}/${data.total})`, 'info');
        });

        socket.on('GAME_STARTED', (data) => {
            myRole = data.role;
            currentPlayers = data.players;
            currentPhase = 'night';

            // Get my name
            const me = currentPlayers.find(p => p.id === myPlayerId);
            const myName = me ? me.name : 'B·∫°n';

            showScreen('game');
            renderRole(data.role, myName);
            setupActionUI('night'); // Start at night
            updateStatusBar('NIGHT 1');
            showPhaseOverlay('NIGHT 1');
            renderSuspicionUI();

            // Note: setupActionUI now handles missing player data by requesting GET_PLAYERS.
        });

        socket.on('PHASE_CHANGED', (data) => {
            currentPhase = data.phase;
            pendingExecutionId = data.pendingExecutionId || null; // Ensure pendingExecutionId is set correctly
            if (data.phase !== 'day') {
                readyCard.style.display = 'none';
            }
            let phaseText = `${data.phase.toUpperCase()} ${data.day}`;
            if (data.phase === 'execution_reveal') phaseText = 'K·∫æT QU·∫¢ B·∫¶U C·ª¨';
            if (data.phase === 'defense') phaseText = 'BI·ªÜN H·ªò üõ°Ô∏è';
            if (data.phase === 'final_verdict') phaseText = 'PHI√äN X√âT X·ª¨ ‚öîÔ∏è';

            document.getElementById('phaseDisplay').innerText = phaseText;
            addTypesLogs(data.logs);
            
            // Calculate countdown duration
            let countdownSecs = 3;
            if (data.phase === 'defense') {
                const now = Date.now();
                if (data.defenseEndsAt) {
                    countdownSecs = Math.max(3, Math.ceil((data.defenseEndsAt - now) / 1000));
                } else {
                    countdownSecs = 30;
                }
            }
            
            // ALWAYS show phase overlay with countdown for ALL phase transitions
            showPhaseOverlay(phaseText, countdownSecs);

            // Check if current player died
            const me = currentPlayers.find(p => p.id === myPlayerId);
            const wasAlive = me && me.alive;

            // Sync players to define Alive status
            socket.emit('GET_PLAYERS');

            // Narrator Popups
            if (data.phase === 'day') {
                showNarrator('BAN NG√ÄY ‚òÄÔ∏è', `Tr·ªùi s√°ng r·ªìi!`);
                suspectLocked = true;

                readySent = false;
                readyCounts.ready = 0;
                // Get total alive non-host players for ready counter
                const aliveNonHost = currentPlayers.filter(p => p.alive && !p.host).length;
                readyCounts.total = aliveNonHost;
                updateReadyUI(aliveNonHost);

                // AI host style narration about night deaths
                const deaths = Array.isArray(data.nightDeaths) ? data.nightDeaths : [];
                let msg = 'ƒê√™m qua l√† m·ªôt ƒë√™m y√™n b√¨nh v√† kh√¥ng c√≥ ai ch·∫øt';
                if (deaths.length === 1) {
                    msg = `ƒê√™m qua c√≥ 1 ng∆∞·ªùi ƒë√£ v·ªÅ v·ªõi √¥ng b√† t·ªï ti√™n. ƒê√≥ l√† ${deaths[0].name}`;
                } else if (deaths.length > 1) {
                    const names = deaths.map(d => d.name).join(', ');
                    msg = `ƒê√™m qua l√† m·ªôt ƒë√™m ƒë·∫´m m√°u - c√≥ ${deaths.length} ng∆∞·ªùi ch·∫øt. ƒê√≥ l√† ${names}`;
                }
                showNarrator('T√ìM T·∫ÆT ƒê√äM QUA', msg);

                // Check if player died during night
                setTimeout(() => {
                    const meNow = currentPlayers.find(p => p.id === myPlayerId);
                    if (wasAlive && meNow && !meNow.alive) {
                        showDeathNotification();
                    }
                }, 500);
            } else if (data.phase === 'vote') {
                showNarrator('B·ªé PHI·∫æU üó≥Ô∏è', 'M·ªçi ng∆∞·ªùi h√£y b·ªè phi·∫øu treo c·ªï!');
                suspectLocked = true;
                readyCard.style.display = 'none';
            } else if (data.phase === 'night') {
                showNarrator('BAN ƒê√äM üåô', `ƒê√™m th·ª© ${data.day}. C√°c ch·ª©c nƒÉng ho·∫°t ƒë·ªông!`);
                suspectLocked = false;
                renderSuspicionUI();
                readyCard.style.display = 'none';

                // Witch fallback: If no WITCH_PREVIEW after 5s, show kill dialog directly
                const me = currentPlayers.find(p => p.id === myPlayerId);
                if (me && me.role === 'witch' && me.alive) {
                    console.log('[WITCH] Setting 5s timeout for fallback dialog');
                    window.witchPreviewTimeout = setTimeout(() => {
                        console.log('[WITCH] No preview received, showing kill dialog directly');
                        showWitchKillDialog();
                    }, 5000);
                }

                // Check if player died during vote/execution
                setTimeout(() => {
                    const meNow = currentPlayers.find(p => p.id === myPlayerId);
                    if (wasAlive && meNow && !meNow.alive) {
                        showDeathNotification();
                    }
                }, 500);
            } else if (data.phase === 'end') {
                // Display winning faction instead of generic game over
                let winnerTitle = 'GAME OVER üèÅ';
                let winnerMsg = 'Tr√≤ ch∆°i k·∫øt th√∫c!';

                if (data.winner === 'WOLVES') {
                    winnerTitle = 'S√ìI CHI·∫æN TH·∫ÆNG! üê∫';
                    winnerMsg = 'Phe S√≥i ƒë√£ ti√™u di·ªát h·∫øt D√¢n L√†ng!';
                } else if (data.winner === 'VILLAGERS') {
                    winnerTitle = 'D√ÇN L√ÄNG CHI·∫æN TH·∫ÆNG! üèÜ';
                    winnerMsg = 'Phe D√¢n L√†ng ƒë√£ ti√™u di·ªát h·∫øt S√≥i!';
                } else if (data.winner === 'TRAITOR') {
                    winnerTitle = 'K·∫∫ PH·∫¢N B·ªòI CHI·∫æN TH·∫ÆNG! üé≠';
                    winnerMsg = 'K·∫ª Ph·∫£n B·ªôi ƒë√£ ho√†n th√†nh m·ª•c ti√™u!';
                }

                showNarrator(winnerTitle, winnerMsg);

                // Mark to return host UI after end if this client is ex-host
                if (fromHost) {
                    sessionStorage.setItem('returnToHost', '1');
                }
            } else if (data.phase === 'execution_reveal') {
                // Wait for player list to sync first
                setTimeout(() => {
                    // Find who was executed from logs or executedPlayerId
                    let victimName = 'ai ƒë√≥';

                    if (data.executedPlayerId) {
                        const victim = currentPlayers.find(p => p.id === data.executedPlayerId);
                        if (victim) {
                            victimName = victim.name;
                        }
                    } else {
                        // Parse from logs if executedPlayerId not available
                        const executionLog = data.logs.find(log => log.includes('ƒë√£ b·ªã treo c·ªï'));
                        if (executionLog) {
                            const match = executionLog.match(/‚öñÔ∏è (.+) ƒë√£ b·ªã treo c·ªï/);
                            if (match) victimName = match[1];
                        }
                    }

                    // Show announcement
                    if (victimName === 'ai ƒë√≥' && !data.executedPlayerId) {
                        showNarrator('K·∫æT QU·∫¢ ‚öñÔ∏è', 'Kh√¥ng ai b·ªã treo c·ªï.');
                    } else {
                        showNarrator('K·∫æT QU·∫¢ TREO C·ªî ‚öñÔ∏è', `${victimName} ƒë√£ b·ªã treo c·ªï!`);

                        // Show death notification to executed player
                        setTimeout(() => {
                            if (data.executedPlayerId === myPlayerId) {
                                showDeathNotification();
                            }
                        }, 1500); // Delay so they see the announcement first
                    }
                }, 600); // Wait for GET_PLAYERS to sync currentPlayers
            } else if (data.phase === 'defense') {
                const victim = currentPlayers.find(p => p.id === pendingExecutionId);
                const victimName = victim ? victim.name : 'ng∆∞·ªùi b·ªã treo c·ªï';
                showNarrator('BI·ªÜN H·ªò üõ°Ô∏è', `${victimName} c√≥ 30s ƒë·ªÉ bi·ªán h·ªô tr∆∞·ªõc khi quy·∫øt ƒë·ªãnh cu·ªëi c√πng.`);
                readyCard.style.display = 'none';
            } else if (data.phase === 'final_verdict') {
                const victim = currentPlayers.find(p => p.id === pendingExecutionId);
                const victimName = victim ? victim.name : 'ng∆∞·ªùi b·ªã treo c·ªï';
                showNarrator('PHI√äN X√âT X·ª¨ ‚öîÔ∏è', `H√£y ch·ªçn: Gi·∫øt ho·∫∑c Kh√¥ng gi·∫øt ${victimName}.`);
                setupActionUI('final_verdict');
                readyCard.style.display = 'none';
            }
        });

        socket.on('GAME_RESET', () => {
            showScreen('lobby');
            document.getElementById('gameLogs').innerHTML = ''; // Clear logs
            showNarrator('RESET', 'Host ƒë√£ reset game. ƒê√£ v·ªÅ l·∫°i ph√≤ng ch·ªù.');

            if (fromHost && sessionStorage.getItem('returnToHost') === '1') {
                sessionStorage.removeItem('returnToHost');
                window.location.href = '/host';
            }
        });

        // Server asks ex-host to return to setup (after end/reset)
        socket.on('HOST_RETURN_TO_SETUP', () => {
            if (fromHost) {
                sessionStorage.removeItem('returnToHost');
                window.location.href = '/host';
            }
        });

        socket.on('HOST_LEFT', (data) => {
            alert(data.message || 'Host ƒë√£ r·ªùi ph√≤ng.');
            // Return to join screen
            window.location.reload();
        });

        // Timer Update Handler
        socket.on('TIMER_UPDATE', (data) => {
            const timerDisplay = document.getElementById('timerDisplay');
            const { timeLeft } = data;

            if (timeLeft !== undefined && timeLeft >= 0) {
                timerDisplay.style.display = 'block';
                timerDisplay.innerText = `‚è±Ô∏è ${timeLeft}s`;

                // Warning styling when time is low
                if (timeLeft <= 10) {
                    timerDisplay.classList.add('warning');
                } else {
                    timerDisplay.classList.remove('warning');
                }
            } else {
                timerDisplay.style.display = 'none';
            }
        });

        // Admin Room Closed Handler
        socket.on('ADMIN_ROOM_CLOSED', (data) => {
            alert(data.message || 'Ph√≤ng ƒë√£ b·ªã ƒë√≥ng b·ªüi Admin');
            window.location.reload();
        });

        // Vote Leader Update Handler
        socket.on('VOTE_LEADER_UPDATE', (data) => {
            const notification = document.getElementById('voteLeaderNotification');
            const leaderName = document.getElementById('voteLeaderName');
            const voteCount = document.getElementById('voteLeaderCount');

            if (data.leaderName && data.voteCount > 0) {
                notification.style.display = 'block';
                leaderName.innerText = data.leaderName;
                voteCount.innerText = `${data.voteCount} / ${data.totalVotes} phi·∫øu`;
                showToast(`ƒêang d·∫´n: ${data.leaderName} (${data.voteCount}/${data.totalVotes})`, 'warn');
            } else {
                notification.style.display = 'none';
            }
        });

        socket.on('SUSPECT_LOG', (data) => {
            addTypesLogs([data.message]);
            showToast('ƒê√£ nh·∫≠n log nghi ng·ªù', 'info');
        });

        socket.on('SUSPECT_VOTE_OK', () => {
            showToast('H·ªá th·ªëng ƒë√£ ghi l·∫°i nghi ng·ªù c·ªßa b·∫°n', 'success');
        });

        // NEW: Vote Cast Notification (Public Vote Visibility)
        socket.on('VOTE_CAST', (data) => {
            const logMsg = `üó≥Ô∏è ${data.voterName} vote ${data.targetName}`;
            addTypesLogs([logMsg]);
        });

        socket.on('FINAL_VOTE_UPDATE', (data) => {
            const msg = `B·ªè phi·∫øu cu·ªëi: Gi·∫øt ${data.executeVotes}/${data.totalVotes} - Kh√¥ng gi·∫øt ${data.spareVotes}/${data.totalVotes}`;
            showToast(msg, 'warn');
        });

        // NEW: Wolf target preview (show to all wolves when any wolf sets KILL target)
        socket.on('WOLF_KILL_PREVIEW', (data) => {
            const me = currentPlayers.find(p => p.id === myPlayerId);
            if (!me || !(me.role === 'wolf' || me.role === 'alphaWolf')) return;

            const banner = document.getElementById('wolfKillNotice');
            const targetSpan = document.getElementById('wolfKillTarget');
            if (!banner || !targetSpan) return;

            targetSpan.innerText = data.targetName || 'Unknown';
            banner.style.display = 'block';
            banner.classList.remove('hidden');
            showToast(`üê∫ ${data.by} vote gi·∫øt ${data.targetName}`, 'warn');
        });

        // Chat sync from server (on join or host toggle)
        socket.on('CHAT_SYNC', (data) => {
            chatEnabled = !!data.enabled;
            if (Array.isArray(data.log)) {
                chatLog = data.log.slice(-20);
            }
            updateChatUI();
        });

        // New chat message broadcast
        socket.on('CHAT_MESSAGE', (msg) => {
            chatLog.push(msg);
            if (chatLog.length > 20) chatLog = chatLog.slice(-20);
            renderChatMessages();
            if (chatEnabled) {
                showToast(`üí¨ ${msg.name}: ${msg.message}`, 'info');
            }
        });

        // NEW: Player Removed Handler (Auto-Disconnect)
        socket.on('PLAYER_REMOVED', (data) => {
            // If I was removed, redirect to join page
            if (data.playerId === myPlayerId) {
                alert(data.message || 'B·∫°n ƒë√£ b·ªã ng·∫Øt k·∫øt n·ªëi');
                localStorage.removeItem('roomCode');
                localStorage.removeItem('playerId');
                localStorage.removeItem('token');
                window.location.href = '/';
                return;
            }

            // Otherwise, just log the removal
            addTypesLogs([data.message || `${data.playerName} ƒë√£ r·ªùi ph√≤ng`]);

            // Refresh player list
            socket.emit('GET_PLAYERS');
        });

        // Handle socket disconnect (network issues)
        socket.on('disconnect', () => {
            console.log('Disconnected from server');
            // Show message and redirect after delay
            setTimeout(() => {
                alert('M·∫•t k·∫øt n·ªëi v·ªõi server');
                window.location.href = '/';
            }, 1000);
        });

        // NEW: Dead Player Observer - Receive HOST_UPDATE
        socket.on('HOST_UPDATE', (data) => {
            // Dead players receive host updates for omniscient view
            const me = currentPlayers.find(p => p.id === myPlayerId);
            if (me && !me.alive) {
                // Display action log details
                if (data.actionLog) {
                    const logMsg = `üîç [Host Log] ${data.actionLog.actorName} (${data.actionLog.actorRole}) ‚Üí ${data.actionLog.actionType} ‚Üí ${data.actionLog.targetName}`;
                    addTypesLogs([logMsg]);
                }
            }
        });

        // NEW: Witch Preview System
        socket.on('WITCH_PREVIEW', (data) => {
            console.log('[WITCH_PREVIEW] Event received:', data);
            console.log('[WITCH_PREVIEW] myPlayerId:', myPlayerId);
            console.log('[WITCH_PREVIEW] myRole:', myRole);
            console.log('[WITCH_PREVIEW] currentPlayers:', currentPlayers);
            
            const me = currentPlayers.find(p => p.id === myPlayerId);
            console.log('[WITCH_PREVIEW] Found me:', me);
            console.log('[WITCH_PREVIEW] My role from player data:', me?.role);

            if (!me || me.role !== 'witch') {
                console.log('[WITCH_PREVIEW] Not witch or player not found, skipping');
                return;
            }

            // Clear any pending timeout
            if (window.witchPreviewTimeout) {
                clearTimeout(window.witchPreviewTimeout);
            }

            console.log('[WITCH_PREVIEW] Showing heal dialog');
            showWitchHealDialog(data.targetName, data.targetId);
        });

        function showWitchHealDialog(targetName, targetId) {
            // Close narrator if open
            narratorOverlay.classList.add('hidden');

            // Create dialog
            const dialog = document.createElement('div');
            dialog.id = 'witchHealDialog';
            dialog.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.9);
                z-index: 2500;
                display: flex;
                justify-content: center;
                align-items: center;
            `;

            dialog.innerHTML = `
                <div style="background: #1e293b; padding: 30px; border-radius: 12px; max-width: 400px; text-align: center; border: 2px solid #10b981;">
                    <h2 style="color: #10b981; margin-bottom: 20px;">‚ö†Ô∏è TH√îNG B√ÅO PH√ô TH·ª¶Y</h2>
                    <p style="color: #fff; font-size: 18px; margin-bottom: 20px;">
                        <strong>${targetName}</strong> s·∫Ω ch·∫øt ƒë√™m nay.
                    </p>
                    <p style="color: #94a3b8; margin-bottom: 30px;">B·∫°n c√≥ mu·ªën c·ª©u kh√¥ng?</p>
                    <div style="display: flex; gap: 15px; justify-content: center;">
                        <button onclick="witchHealDecision(true, '${targetId}')" 
                            style="padding: 15px 30px; font-size: 16px; background: #10b981; color: #fff; border: none; border-radius: 8px; cursor: pointer; font-weight: bold;">
                            C·ª®U
                        </button>
                        <button onclick="witchHealDecision(false, '${targetId}')" 
                            style="padding: 15px 30px; font-size: 16px; background: #ef4444; color: #fff; border: none; border-radius: 8px; cursor: pointer; font-weight: bold;">
                            KH√îNG
                        </button>
                    </div>
                </div>
            `;

            document.body.appendChild(dialog);
        }

        function witchHealDecision(shouldHeal, targetId) {
            // Remove heal dialog
            const dialog = document.getElementById('witchHealDialog');
            if (dialog) dialog.remove();

            // If heal, submit SAVE action
            if (shouldHeal) {
                socket.emit('ACTION', { type: 'SAVE', targetId: targetId });
                console.log('[WITCH] Submitted SAVE for', targetId);
            }

            // Show kill dialog
            setTimeout(() => showWitchKillDialog(), 500);
        }

        function showWitchKillDialog() {
            const dialog = document.createElement('div');
            dialog.id = 'witchKillDialog';
            dialog.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.9);
                z-index: 2500;
                display: flex;
                justify-content: center;
                align-items: center;
                flex-direction: column;
            `;

            dialog.innerHTML = `
                <div style="background: #1e293b; padding: 30px; border-radius: 12px; max-width: 500px; text-align: center; border: 2px solid #a855f7;">
                    <h2 style="color: #a855f7; margin-bottom: 20px;">üß™ PH√ô TH·ª¶Y - D√ôNG ƒê·ªòC</h2>
                    <p style="color: #94a3b8; margin-bottom: 20px;">B·∫°n c√≥ mu·ªën gi·∫øt ai kh√¥ng?</p>
                    <div id="witchKillTargets" style="max-height: 300px; overflow-y: auto; margin-bottom: 20px;"></div>
                    <button onclick="witchSkipKill()" 
                        style="padding: 15px 30px; font-size: 16px; background: #64748b; color: #fff; border: none; border-radius: 8px; cursor: pointer; font-weight: bold;">
                        B·ªé QUA
                    </button>
                </div>
            `;

            document.body.appendChild(dialog);

            // Populate targets
            const container = document.getElementById('witchKillTargets');
            currentPlayers.filter(p => !p.isHost && p.alive).forEach(p => {
                const btn = document.createElement('button');
                btn.innerText = p.name;
                btn.style.cssText = `
                    display: block;
                    width: 100%;
                    padding: 12px;
                    margin: 8px 0;
                    background: #334155;
                    color: #fff;
                    border: 2px solid #475569;
                    border-radius: 8px;
                    cursor: pointer;
                    font-size: 16px;
                `;
                btn.onclick = () => witchKillTarget(p.id);
                btn.onmouseover = () => btn.style.background = '#475569';
                btn.onmouseout = () => btn.style.background = '#334155';
                container.appendChild(btn);
            });
        }

        function witchKillTarget(targetId) {
            socket.emit('ACTION', { type: 'KILL', targetId: targetId });
            console.log('[WITCH] Submitted KILL for', targetId);

            const dialog = document.getElementById('witchKillDialog');
            if (dialog) dialog.remove();

            alert('ƒê√£ g·ª≠i h√†nh ƒë·ªông Ph√π Th·ªßy!');
        }

        function witchSkipKill() {
            // Submit SKIP action so server knows Witch is done
            socket.emit('ACTION', { type: 'SKIP', targetId: null });
            console.log('[WITCH] Submitted SKIP');
            
            const dialog = document.getElementById('witchKillDialog');
            if (dialog) dialog.remove();

            showToast('ƒê√£ b·ªè qua gi·∫øt ng∆∞·ªùi', 'info');
        }

        socket.on('ERROR', (data) => alert(data.message));

        // --- NOTIFICATION ---
        const narratorOverlay = document.getElementById('narratorOverlay');
        function showNarrator(title, msg) {
            document.getElementById('narTitle').innerText = title;
            document.getElementById('narMessage').innerText = msg;
            narratorOverlay.classList.remove('hidden');
            narratorOverlay.style.display = 'flex';
        }

        window.closeNarrator = () => {
            narratorOverlay.classList.add('hidden');
            narratorOverlay.style.display = 'none';
        };

        // --- ROLE GUIDE MODAL ---
        window.showRoleGuide = () => {
            if (!myRole) return;

            const guide = ROLE_GUIDES[myRole];
            if (!guide) return;

            const content = document.getElementById('roleGuideContent');
            content.innerHTML = `
                <h2>${guide.title}</h2>
                <p><strong>Phe:</strong> ${guide.faction}</p>
                <p><strong>ƒêi·ªÅu ki·ªán th·∫Øng:</strong> ${guide.winCondition}</p>
                
                <h3>üéØ Kh·∫£ nƒÉng</h3>
                <ul>
                    ${guide.abilities.map(a => `<li>${a}</li>`).join('')}
                </ul>
                
                <h3>‚öôÔ∏è C∆° ch·∫ø</h3>
                <ul>
                    ${guide.mechanics.map(m => `<li>${m}</li>`).join('')}
                </ul>
                
                <button class="guide-close-btn" onclick="closeRoleGuide()">ƒê√≥ng</button>
            `;

            const modal = document.getElementById('roleGuideModal');
            modal.classList.remove('hidden');
            modal.style.display = 'flex';
        };

        window.closeRoleGuide = () => {
            const modal = document.getElementById('roleGuideModal');
            modal.classList.add('hidden');
            modal.style.display = 'none';
        };

        // Floating action toggle
        const toggleFab = document.getElementById('toggleActionFab');
        toggleFab.onclick = () => {
            const area = document.getElementById('actionArea');
            area.classList.toggle('hidden');
            toggleFab.innerText = area.classList.contains('hidden') ? 'üß≠' : '‚ö°';
        };

        // --- DEATH NOTIFICATION (Enhanced) ---
        function showDeathNotification() {
            // Create dramatic death overlay
            const deathOverlay = document.createElement('div');
            deathOverlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(139, 0, 0, 0.95);
                z-index: 3000;
                display: flex;
                justify-content: center;
                align-items: center;
                flex-direction: column;
                animation: fadeIn 0.5s ease-in;
            `;

            deathOverlay.innerHTML = `
                <div style="text-align: center; color: #fff; padding: 30px;">
                    <div style="font-size: 80px; margin-bottom: 20px; animation: pulse 1.5s infinite;">üíÄ</div>
                    <h1 style="font-size: 48px; color: #ff4444; margin-bottom: 20px; text-transform: uppercase; text-shadow: 0 0 20px #ff0000, 0 0 40px #ff0000; font-weight: bold; letter-spacing: 3px;">B·∫†N ƒê√É CH·∫æT</h1>
                    <p style="font-size: 24px; line-height: 1.8; color: #ffcccc; max-width: 400px; margin: 0 auto 30px; text-shadow: 0 2px 4px rgba(0,0,0,0.5);">
                        B·∫°n ƒë√£ b·ªã lo·∫°i kh·ªèi tr√≤ ch∆°i.<br>
                        B·∫°n c√≥ th·ªÉ theo d√µi game ti·∫øp t·ª•c.
                    </p>
                    <button onclick="this.parentElement.parentElement.remove()" 
                        style="padding: 15px 40px; font-size: 20px; font-weight: bold; background: #000; color: #ff4444; border: 2px solid #ff4444; border-radius: 8px; cursor: pointer; text-transform: uppercase; letter-spacing: 2px;">
                        ƒê√≥ng
                    </button>
                </div>
                <style>
                    @keyframes fadeIn {
                        from { opacity: 0; }
                        to { opacity: 1; }
                    }
                    @keyframes pulse {
                        0%, 100% { transform: scale(1); }
                        50% { transform: scale(1.1); }
                    }
                </style>
            `;

            document.body.appendChild(deathOverlay);
        }

        // --- CHAT UI ---
        function updateChatUI() {
            if (!chatCard) return;
            chatCard.style.display = chatEnabled ? 'block' : 'none';
            if (chatEnabled) {
                chatSendBtn.disabled = false;
                chatInput.disabled = false;
                chatDisabled.classList.add('hidden');
            } else {
                chatSendBtn.disabled = true;
                chatInput.disabled = true;
                chatDisabled.classList.remove('hidden');
            }
            renderChatMessages();
        }

        function renderChatMessages() {
            if (!chatMessagesEl) return;
            chatMessagesEl.innerHTML = '';
            const formatter = new Intl.DateTimeFormat('vi-VN', { hour: '2-digit', minute: '2-digit' });
            chatLog.forEach(m => {
                const div = document.createElement('div');
                div.className = 'chat-entry';
                const time = formatter.format(new Date(m.ts || Date.now()));
                div.innerHTML = `<span class="name">${m.name || '·∫®n danh'}</span><span class="msg">${escapeHtml(m.message)}</span><span class="time">${time}</span>`;
                chatMessagesEl.appendChild(div);
            });
            chatMessagesEl.scrollTop = chatMessagesEl.scrollHeight;
        }

        // simple escape
        function escapeHtml(str) {
            return String(str || '')
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;');
        }

        // --- UI FUNCTIONS ---

        function showScreen(name) {
            Object.values(screens).forEach(s => s.classList.add('hidden'));
            screens[name].classList.remove('hidden');
        }

        function renderLobby(players) {
            const container = document.getElementById('lobbyPlayerList');
            container.innerHTML = players.map(p => `
                <div class="player-item">
                    <div class="status-dot ${p.connected ? 'online' : 'offline'}"></div>
                    <div>${p.name} ${p.isHost ? '(Host)' : ''}</div>
                </div>
            `).join('');
        }

        function renderRole(role, name) {
            const titles = {
                alphaWolf: 'S√≥i ƒê·∫ßu ƒê√†n üê∫',
                wolf: 'S√≥i Th∆∞·ªùng üê∫',
                detective: 'Th√°m T·ª≠ üïµÔ∏è',
                seer: 'Ti√™n Tri üîÆ',
                witch: 'Ph√π Th·ªßy üßô',
                hunter: 'Th·ª£ SƒÉn üèπ',
                lawyer: 'Lu·∫≠t S∆∞ ‚öñÔ∏è',
                traitor: 'K·∫ª Ph·∫£n B·ªôi üé≠',
                villager: 'D√¢n L√†ng üßë‚Äçüåæ'
            };
            const descs = {
                alphaWolf: 'Ch·ªçn m·ª•c ti√™u ƒë·ªÉ NGUN R·ª¶A (h·ªìi sinh + h√≥a s√≥i n·∫øu ch·∫øt b·ªüi s√≥i). C√πng s√≥i th∆∞·ªùng ch·ªçn m·ª•c ti√™u gi·∫øt.',
                wolf: 'Ch·ªçn m·ª•c ti√™u ƒë·ªÉ gi·∫øt v√†o ban ƒë√™m.',
                detective: 'Soi m·ªôt ng∆∞·ªùi ƒë·ªÉ bi·∫øt h·ªç c√≥ h√†nh ƒë·ªông ƒë√™m hay kh√¥ng.',
                seer: 'Soi m·ªôt ng∆∞·ªùi ƒë·ªÉ bi·∫øt h·ªç l√† S√≥i hay Ng∆∞·ªùi.',
                witch: 'C√≥ b√¨nh thu·ªëc ƒë·ªÉ GI·∫æT ng∆∞·ªùi ch∆°i kh√°c v√†o ban ƒë√™m.',
                hunter: 'N·∫øu b·ªã gi·∫øt ho·∫∑c treo c·ªï, danh t√≠nh s·∫Ω ƒë∆∞·ª£c c√¥ng b·ªë (v√† c√≥ th·ªÉ k√©o theo ng∆∞·ªùi kh√°c - T√πy Host).',
                lawyer: 'Ch·ªçn m·ªôt ng∆∞·ªùi ƒë·ªÉ b·∫£o v·ªá kh·ªèi √°n treo c·ªï ng√†y mai.',
                traitor: 'C·ªë g·∫Øng b·ªã treo c·ªï ho·∫∑c b·ªã s√≥i c·∫Øn ƒë√™m ƒë·∫ßu ƒë·ªÉ th·∫Øng.',
                villager: 'Ng·ªß v√† c·ªë g·∫Øng s·ªëng s√≥t.'
            };

            document.getElementById('roleName').innerText = `${name} - ${titles[role] || role}`;
            document.getElementById('roleDesc').innerText = descs[role] || '';

            const badgeText = document.getElementById('roleBadgeText');
            const badgeIcon = document.getElementById('roleBadgeIcon');
            badgeText.innerText = `Vai tr√≤: ${titles[role] || role}`;
            badgeIcon.innerText = ROLE_ICONS[role] || 'üß©';

            updateStatusBar();
        }

        function setupActionUI(phase) {
            const container = document.getElementById('playerSelect');
            const title = document.getElementById('actionTitle');
            const btn = document.getElementById('confirmActionBtn');
            const actionArea = document.getElementById('actionArea');

            container.innerHTML = '';
            selectedTarget = null;
            btn.disabled = false;
            btn.innerText = 'X√ÅC NH·∫¨N';
            btn.style.display = 'block'; // Reset display in case it was hidden

            let showActions = false;
            let actionType = '';

            // Check Alive Status
            const me = currentPlayers.find(p => p.id === myPlayerId);
            console.log('[setupActionUI] phase=', phase, 'myPlayerId=', myPlayerId, 'me=', me ? `${me.name} alive=${me.alive}` : 'NOT FOUND');
            if (!me) {
                // Not synced yet: DON'T treat as dead. Show loading state.
                actionArea.classList.add('hidden');
                title.innerHTML = '‚è≥ ƒêANG ƒê·ªíNG B·ªò';
                container.innerHTML = '<p style="color: #94a3b8; text-align: center; padding: 20px;">ƒêang t·∫£i d·ªØ li·ªáu ng∆∞·ªùi ch∆°i... vui l√≤ng ƒë·ª£i 1 ch√∫t.</p>';
                actionArea.classList.remove('hidden');
                btn.style.display = 'none';

                // Ask server for latest state
                console.log('[setupActionUI] Requesting GET_PLAYERS because me not found');
                try { socket.emit('GET_PLAYERS'); } catch (e) { }
                return;
            }

            if (!me.alive) {
                // If dead, hide actions but show observer mode indicator
                actionArea.classList.add('hidden');

                // Show observer mode indicator
                title.innerHTML = 'üëª CH·∫æ ƒê·ªò QUAN S√ÅT';
                container.innerHTML = '<p style="color: #94a3b8; text-align: center; padding: 20px;">B·∫°n ƒë√£ ch·∫øt. B·∫°n c√≥ th·ªÉ xem to√†n b·ªô vai tr√≤ v√† h√†nh ƒë·ªông c·ªßa ng∆∞·ªùi ch∆°i kh√°c.</p>';
                actionArea.classList.remove('hidden');
                btn.style.display = 'none';
                return;
            }

            if (phase === 'night') {
                if (['wolf', 'alphaWolf'].includes(myRole)) {
                    showActions = true;
                    title.innerHTML = 'Ch·ªçn m·ª•c ti√™u <br>' +
                        (myRole === 'alphaWolf' ?
                            '<div style="margin-top:10px; font-size:14px;"><label><input type="radio" name="wType" value="KILL" checked> KILL</label> <label style="margin-left:15px;"><input type="radio" name="wType" value="CURSE"> CURSE (1 time)</label></div>'
                            : '(KILL Only)');
                    actionType = 'KILL'; // Default

                    // Add listener for radio change
                    setTimeout(() => {
                        document.querySelectorAll('input[name="wType"]').forEach(r => {
                            r.onchange = (e) => actionType = e.target.value;
                        });
                    }, 100);
                } else if (myRole === 'detective') {
                    showActions = true;
                    title.innerText = 'Ch·ªçn ng∆∞·ªùi ƒë·ªÉ TH√ÅM T·ª¨ SOI (Ho·∫°t ƒë·ªông?)';
                    actionType = 'CHECK';
                } else if (myRole === 'seer') {
                    showActions = true;
                    title.innerText = 'Ch·ªçn ng∆∞·ªùi ƒë·ªÉ TI√äN TRI SOI (S√≥i/Ng∆∞·ªùi?)';
                    actionType = 'CHECK';
                } else if (myRole === 'seer') {
                    showActions = true;
                    title.innerText = 'Ch·ªçn ng∆∞·ªùi ƒë·ªÉ TI√äN TRI SOI (S√≥i/Ng∆∞·ªùi?)';
                    actionType = 'CHECK';
                } else if (myRole === 'bodyguard') {
                    showActions = true;
                    title.innerText = 'Ch·ªçn ng∆∞·ªùi ƒë·ªÉ B·∫¢O V·ªÜ (Kh√¥ng ƒë∆∞·ª£c tr√πng 2 ƒë√™m li√™n ti·∫øp)';
                    actionType = 'PROTECT';
                } else if (myRole === 'hunter') {
                    showActions = true;
                    title.innerText = 'Ch·ªçn ng∆∞·ªùi ƒë·ªÉ GHIM (Ch·∫øt chung n·∫øu b·∫°n ch·∫øt)';
                    actionType = 'PIN';
                } else if (myRole === 'witch') {
                    showActions = true;
                    title.innerHTML = 'PH√ô TH·ª¶Y <br>' +
                        '<div style="margin-top:10px; font-size:14px;">' +
                        '<label><input type="radio" name="witchAction" value="KILL" checked> D√ôNG ƒê·ªòC (KILL)</label>' +
                        '</div>';
                    // Save potion disabled for MVP automation complexity, allow Manual Save?
                    // User said "Host tells Witch". 
                    // If Host tells, Witch needs to select the person to Save.
                    // So we need a SAVE option.

                    // Add Save Option
                    title.innerHTML = 'PH√ô TH·ª¶Y <br>' +
                        '<div style="margin-top:10px; font-size:14px;">' +
                        '<label><input type="radio" name="witchAction" value="KILL" checked> GI·∫æT (ƒê·ªôc)</label>' +
                        '<label style="margin-left:10px;"><input type="radio" name="witchAction" value="SAVE"> C·ª®U (H·ªìi sinh)</label>' +
                        '</div>';

                    actionType = 'KILL'; // Default

                    setTimeout(() => {
                        document.querySelectorAll('input[name="witchAction"]').forEach(r => {
                            r.onchange = (e) => actionType = e.target.value;
                        });
                    }, 100);
                }
            } else if (phase === 'game' || phase === 'vote') { // Vote Phase
                showActions = true;
                title.innerText = 'B·ªè phi·∫øu treo c·ªï';
                actionType = 'VOTE';

                // Lawyer check logic...
            } else if (phase === 'final_verdict') {
                showActions = true;
                title.innerText = 'Quy·∫øt ƒë·ªãnh cu·ªëi: Gi·∫øt hay Kh√¥ng gi·∫øt?';
                actionType = 'FINAL_VOTE';
            }

            if (!showActions) {
                actionArea.classList.add('hidden');
                return;
            }
            actionArea.classList.remove('hidden');

            // Hide wolf banner by default; will show on preview events
            const wolfBanner = document.getElementById('wolfKillNotice');
            if (wolfBanner) {
                wolfBanner.style.display = 'none';
                wolfBanner.classList.add('hidden');
            }

            if (actionType === 'FINAL_VOTE') {
                const options = [
                    { id: 'EXECUTE', label: '‚öîÔ∏è Gi·∫øt' },
                    { id: 'SPARE', label: 'üôè Kh√¥ng gi·∫øt' }
                ];

                options.forEach(opt => {
                    const div = document.createElement('div');
                    div.className = 'action-btn';
                    div.innerText = opt.label;
                    div.onclick = () => {
                        document.querySelectorAll('.action-btn').forEach(b => b.classList.remove('selected'));
                        div.classList.add('selected');
                        selectedTarget = opt.id;
                    };
                    container.appendChild(div);
                });
            } else {
                // Render targets (Alive players excluding self and Host)
                // IMPORTANT: Filter out dead players from vote list
                currentPlayers.filter(p => !p.isHost && p.alive).forEach(p => {
                    // Self-targeting allowed?
                    // Bodyguard: Can protect self? Usually yes.
                    // Witch: Can save self? Usually yes (once).
                    // Hunter: Pin self? No.
                    if (p.id === myPlayerId) {
                        if (actionType === 'PIN') return; // Hunter cant pin self
                        // Others allowed
                    }

                    const div = document.createElement('div');
                    div.className = 'action-btn';

                    // Show wolf icon for other wolves (so wolves can recognize each other)
                    let displayName = p.name;
                    if ((myRole === 'wolf' || myRole === 'alphaWolf') &&
                        (p.role === 'wolf' || p.role === 'alphaWolf')) {
                        displayName = p.name + ' üê∫';
                    }

                    div.innerText = displayName;
                    div.onclick = () => {
                        document.querySelectorAll('.action-btn').forEach(b => b.classList.remove('selected'));
                        div.classList.add('selected');
                        selectedTarget = p.id;
                    };
                    container.appendChild(div);
                });

                // Add SKIP button for vote phase
                if (actionType === 'VOTE') {
                    const skipDiv = document.createElement('div');
                    skipDiv.className = 'action-btn';
                    skipDiv.style.background = '#475569';
                    skipDiv.style.borderColor = '#64748b';
                    skipDiv.innerText = '‚è≠Ô∏è B·ªè qua';
                    skipDiv.onclick = () => {
                        document.querySelectorAll('.action-btn').forEach(b => b.classList.remove('selected'));
                        skipDiv.classList.add('selected');
                        selectedTarget = 'SKIP';
                    };
                    container.appendChild(skipDiv);
                }
            }

            btn.onclick = () => {
                if (!selectedTarget) return alert('Ch∆∞a ch·ªçn m·ª•c ti√™u!');

                if (actionType === 'VOTE') {
                    socket.emit('VOTE', { targetId: selectedTarget });
                    showToast('ƒê√£ g·ª≠i phi·∫øu', 'success');
                } else if (actionType === 'FINAL_VOTE') {
                    socket.emit('VOTE', { targetId: selectedTarget });
                    showToast('ƒê√£ g·ª≠i l·ª±a ch·ªçn cu·ªëi', 'success');
                } else {
                    socket.emit('ACTION', { type: actionType, targetId: selectedTarget });
                    showToast('ƒê√£ g·ª≠i h√†nh ƒë·ªông', 'success');
                }

                btn.disabled = true;
                btn.innerText = 'ƒê√£ G·ª≠i';

                // Hide button after sending
                setTimeout(() => {
                    btn.style.display = 'none';
                }, 500);
            };

            // Suspicion panel always rendered in night for all roles
            renderSuspicionUI();
        }

        function addTypesLogs(logs) {
            const container = document.getElementById('gameLogs');
            logs.forEach(msg => {
                const div = document.createElement('div');
                div.innerText = msg;
                container.prepend(div);
            });
        }
    </script>
</body>

</html>